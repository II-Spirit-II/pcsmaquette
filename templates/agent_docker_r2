#!/bin/sh
#
# OCF agent for Docker containers management
#
# License: GNU General Public License (GPL)
#

# Initialization
: ${OCF_FUNCTIONS_DIR=${OCF_ROOT}/lib/heartbeat}
. ${OCF_FUNCTIONS_DIR}/ocf-shellfuncs

# Defaults
DOCKER=/usr/bin/docker
CONTAINER_DB="/vagrant/shared/containers.db"
INIT_SCRIPTS_DIR="/vagrant/init_scripts"
MAX_RETRIES=3

docker_usage() {
    cat <<END
        usage: $0 {start|stop|monitor|meta-data}
END
}

docker_meta_data() {
    cat <<END
<?xml version="1.0"?>
<!DOCTYPE resource-agent SYSTEM "ra-api-1.dtd">
<resource-agent name="agent_docker_r2">
<version>1.0</version>
<longdesc lang="en">
Resource agent for managing Docker containers
</longdesc>
<shortdesc lang="en">Docker containers RA</shortdesc>
<parameters>
</parameters>
<actions>
<action name="start"        timeout="60s" />
<action name="stop"         timeout="60s" />
<action name="monitor"      timeout="30s" interval="30s" depth="0" />
<action name="meta-data"    timeout="5s" />
</actions>
</resource-agent>
END
}

# Exécute les scripts d'initialisation si présents
run_init_scripts() {
    if [ -d "$INIT_SCRIPTS_DIR" ]; then
        ocf_log info "Checking for initialization scripts in $INIT_SCRIPTS_DIR"
        for script in $INIT_SCRIPTS_DIR/*.sh; do
            if [ -x "$script" ]; then
                ocf_log info "Running initialization script: $script"
                $script
                if [ $? -ne 0 ]; then
                    ocf_log warn "Initialization script $script failed"
                fi
            fi
        done
    else
        ocf_log info "No initialization scripts directory found"
    fi
}

# Enregistre les conteneurs pour le failover
register_containers() {
    if [ ! -d "$(dirname $CONTAINER_DB)" ]; then
        mkdir -p "$(dirname $CONTAINER_DB)"
    fi
    
    # Sauvegarder les informations des conteneurs en cours d'exécution
    $DOCKER ps --format "{{.ID}}:{{.Image}}:{{.Names}}:{{.Ports}}" > "${CONTAINER_DB}.new"
    mv "${CONTAINER_DB}.new" "${CONTAINER_DB}"
    chmod 666 "${CONTAINER_DB}"
    
    ocf_log info "Containers registered for failover: $(cat ${CONTAINER_DB} | wc -l) containers"
}

# Récupère et restaure les conteneurs en cas de failover
restore_containers() {
    if [ ! -f "${CONTAINER_DB}" ]; then
        ocf_log info "No container database found, nothing to restore"
        return 0
    fi
    
    # DEBUG: afficher le contenu du fichier de la base de données
    ocf_log info "RESTORE: Container DB content: $(cat ${CONTAINER_DB})"

    # Lire chaque ligne du fichier de base de données de conteneurs
    while IFS=':' read -r id image name ports; do
        # Ignorer les lignes vides
        if [ -z "$name" ] || [ -z "$image" ]; then
            continue
        fi
        
        ocf_log info "RESTORE: Processing container: $name (image: $image, ports: $ports)"

        # Vérifier si le conteneur existe déjà
        if ! $DOCKER ps -a --format '{{.Names}}' | grep -q "$name"; then
            ocf_log info "Restoring container $name from image $image"
            
            # Tirer l'image si nécessaire
            if ! $DOCKER image inspect "$image" >/dev/null 2>&1; then
                ocf_log info "Pulling image $image"
                $DOCKER pull "$image"
                if [ $? -ne 0 ]; then
                    ocf_log err "Failed to pull image $image"
                    continue
                fi
            fi
            
            # Extraire le mapping de port
            port_args=""
            if [ ! -z "$ports" ]; then
                # Format simplifié pour extraire juste les ports
                host_port=$(echo $ports | grep -oE '[0-9]+:' | tr -d ':' | head -1)
                container_port=$(echo $ports | grep -oE ':[0-9]+/' | tr -d ':/' | head -1)
                
                if [ ! -z "$host_port" ] && [ ! -z "$container_port" ]; then
                    port_args="-p $host_port:$container_port"
                fi
            fi
            
            # Créer et démarrer le conteneur
            $DOCKER run -d --name "$name" $port_args "$image"
            
            # Vérifier si le conteneur a démarré
            if ! $DOCKER ps | grep -q "$name"; then
                ocf_log err "Failed to restore container $name"
            else
                ocf_log info "Container $name successfully restored"
            fi
        elif ! $DOCKER ps | grep -q "$name"; then
            # Le conteneur existe mais n'est pas en cours d'exécution
            ocf_log info "Starting existing container $name"
            $DOCKER start "$name"
            
            # Vérifier si le conteneur a démarré
            if ! $DOCKER ps | grep -q "$name"; then
                ocf_log err "Failed to start container $name"
            fi
        fi
    done < "${CONTAINER_DB}"
}

# Vérifie l'état des conteneurs et tente de les réparer si nécessaire
check_and_repair_containers() {
    local retry_count=0
    local containers_ok=false
    
    while [ $retry_count -lt $MAX_RETRIES ] && [ "$containers_ok" = "false" ]; do
        # Vérifier si des conteneurs sont enregistrés mais pas en cours d'exécution
        if [ -f "${CONTAINER_DB}" ] && [ -s "${CONTAINER_DB}" ]; then
            local missing_containers=false
            
            while IFS=':' read -r id image name ports; do
                if [ -z "$name" ] || [ -z "$image" ]; then
                    continue
                fi
                
                if ! $DOCKER ps | grep -q "$name"; then
                    missing_containers=true
                    ocf_log warn "Container $name is registered but not running"
                fi
            done < "${CONTAINER_DB}"
            
            if [ "$missing_containers" = "true" ]; then
                ocf_log info "Attempting to repair missing containers (attempt $((retry_count+1))/$MAX_RETRIES)"
                restore_containers
                retry_count=$((retry_count+1))
                sleep 2
            else
                containers_ok=true
            fi
        else
            # Pas de conteneurs enregistrés, donc tout est OK
            containers_ok=true
        fi
    done
    
    if [ "$containers_ok" = "false" ]; then
        ocf_log err "Failed to repair containers after $MAX_RETRIES attempts"
        return 1
    fi
    
    return 0
}

docker_monitor() {
    # Vérifier si le service Docker est en cours d'exécution
    if ! systemctl is-active docker >/dev/null 2>&1; then
        ocf_log err "Docker service is not running"
        return $OCF_ERR_GENERIC
    fi
    
    # Enregistrer les conteneurs actuellement en cours d'exécution
    register_containers
    
    # Journaliser le statut actuel
    ocf_log info "MONITOR: Currently running containers: $($DOCKER ps --format '{{.Names}}' | tr '\n' ' ')"
    if [ -f "${CONTAINER_DB}" ]; then
        ocf_log info "MONITOR: Registered containers in DB: $(cat ${CONTAINER_DB} | tr '\n' ' ')"
    else
        ocf_log info "MONITOR: No container database found"
    fi
    
    # Vérifier et réparer les conteneurs si nécessaire
    check_and_repair_containers
    if [ $? -ne 0 ]; then
        return $OCF_NOT_RUNNING
    fi
    
    return $OCF_SUCCESS
}

docker_start() {
    # Exécuter les scripts d'initialisation
    run_init_scripts
    
    # Restaurer les conteneurs enregistrés
    restore_containers
    
    # Vérifier et réparer les conteneurs si nécessaire
    check_and_repair_containers
    if [ $? -ne 0 ]; then
        return $OCF_ERR_GENERIC
    fi
    
    return $OCF_SUCCESS
}

docker_stop() {
    # Enregistrer les conteneurs avant de les arrêter
    register_containers
    
    # Arrêter tous les conteneurs
    running_containers=$($DOCKER ps -q)
    
    if [ -z "$running_containers" ]; then
        ocf_log info "No running containers to stop"
        return $OCF_SUCCESS
    fi
    
    for container in $running_containers; do
        container_name=$($DOCKER inspect --format='{{.Name}}' $container | sed 's/^\///')
        ocf_log info "Stopping container $container_name"
        
        $DOCKER stop $container
        if [ $? -ne 0 ]; then
            ocf_log err "Failed to stop container $container_name"
            # Continue avec les autres conteneurs
        fi
    done
    
    return $OCF_SUCCESS
}

case $1 in
    meta-data)
        docker_meta_data
        exit $OCF_SUCCESS
        ;;
    start)
        docker_start
        ;;
    stop)
        docker_stop
        ;;
    monitor)
        docker_monitor
        ;;
    usage|help)
        docker_usage
        exit $OCF_SUCCESS
        ;;
    *)
        docker_usage
        exit $OCF_ERR_UNIMPLEMENTED
        ;;
esac 